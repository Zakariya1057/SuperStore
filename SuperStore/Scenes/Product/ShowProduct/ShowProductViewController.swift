//
//  ShowProductViewController.swift
//  SuperStore
//
//  Created by Zakariya Mohummed on 27/02/2021.
//  Copyright (c) 2021 Zakariya Mohummed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Cosmos
import ImageSlideshow
import AlamofireImage

protocol ShowProductDisplayLogic: AnyObject
{
    func displayProduct(viewModel: ShowProduct.GetProduct.ViewModel)
    func displayFavourite(viewModel: ShowProduct.UpdateFavourite.ViewModel)
    func displayMonitoring(viewModel: ShowProduct.UpdateMonitoring.ViewModel)
    
    func displayListItem(viewModel: ShowProduct.GetListItem.ViewModel)
    func displayCreatedListItem(viewModel: ShowProduct.CreateListItem.ViewModel)
    func displayUpdatedListItem(viewModel: ShowProduct.UpdateListItem.ViewModel)
}

class ShowProductViewController: UIViewController, ShowProductDisplayLogic
{
    
    var interactor: ShowProductBusinessLogic?
    var router: (NSObjectProtocol & ShowProductRoutingLogic & ShowProductDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = ShowProductInteractor()
        let presenter = ShowProductPresenter()
        let router = ShowProductRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        
        addBorders()
        
        getProduct()
        setupImageSlider()
        registerReviewsTableView()
        setupGestureRecognizer()
    }
    
    @IBOutlet var slideshow: ImageSlideshow!
    
    
    // MARK: IB Outlets
    
    @IBOutlet var addButton: UIButton!
    @IBOutlet var stepperStackView: UIStackView!
    
    @IBOutlet var quantityStepper: UIStepper!
    @IBOutlet var quantityLabel: UILabel!
    
    @IBOutlet weak var nutritionView: UIView!
    @IBOutlet var featuresView: UIView!
    @IBOutlet var dimensionsView: UIView!
    @IBOutlet weak var ingredientsView: UIView!
    @IBOutlet weak var categoriesView: UIView!
    
    @IBOutlet weak var reviewsStackView: UIStackView!
    @IBOutlet weak var allReviewsView: UIView!
    @IBOutlet weak var allReviewsButton: UIButton!
    
    @IBOutlet weak var dietaryView: UIStackView!
    @IBOutlet weak var allergenView: UIStackView!
    @IBOutlet weak var promotionView: UIView!
    @IBOutlet weak var favouriteBarItem: UIBarButtonItem!
    
    @IBOutlet weak var oldPriceView: UIView!
    
    // Field Labels
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var priceLabel: UILabel!
    @IBOutlet weak var oldPriceLabel: UILabel!
    @IBOutlet weak var lifeStyleLabel: UILabel!
    @IBOutlet weak var allergenLabel: UILabel!
    
    @IBOutlet var favouriteButton: UIButton!
    
    @IBOutlet weak var weightLabel: UILabel!
    @IBOutlet var weightParentView: UIView!
    @IBOutlet var weightView: UIView!
    
    @IBOutlet weak var categoriesNameLabel: UILabel!
    @IBOutlet weak var promotionLabel: UILabel!
    @IBOutlet weak var ratingView: CosmosView!
    @IBOutlet weak var parentRatingView: UIView!
    
    @IBOutlet weak var reviewsTableView: UITableView!
    
    @IBOutlet weak var monitorButton: UIButton!
    @IBOutlet weak var recommendedView: UIView!
    @IBOutlet weak var recommendedTableView: UITableView!
    @IBOutlet weak var addToListButton: UIButton!
    
    @IBOutlet var descriptionStackView: UIStackView!
    @IBOutlet var descriptionExpandView: UIView!
    @IBOutlet var descriptionLabel: UILabel!
    @IBOutlet var descriptionButton: UIButton!
    
    var fullDescription: Bool = false
    
    var product: ProductModel!
    var displayedProduct: ShowProduct.DisplayedProduct?
    
    var loading: Bool = true
    
    var scrollPosition: CGFloat = 0
    
    var reviews: [ReviewModel] = []
    var recommendedProducts: [ProductModel] = []
    
    var userSession: UserSessionWorker = UserSessionWorker()
    var loggedIn: Bool {
        return userSession.isLoggedIn()
    }
    
    func getProduct()
    {
        let request = ShowProduct.GetProduct.Request()
        interactor?.getProduct(request: request)
    }
    
    func getListItem(){
        if let listID = interactor?.selectedListID {
            let request = ShowProduct.GetListItem.Request(listID: listID, productID: product.id)
            interactor?.getListItem(request: request)
        }
    }
    
    func displayProduct(viewModel: ShowProduct.GetProduct.ViewModel)
    {
        if let error = viewModel.error {
            
            if !viewModel.offline {
                showError(title: "Product Error", error: error)
            }
            
        } else {
            
            loading = false
            
            if let displayedProduct = viewModel.displayedProduct {
                
                self.product = viewModel.product
                self.displayedProduct = displayedProduct
                
                getListItem()
                
                toggleFavouriteButton(favourite: displayedProduct.favourite)
                toggleMonitorButton(monitor: displayedProduct.monitoring)
                
                displayImages(largeImage: displayedProduct.largeImage, images: displayedProduct.images)
                
                displayName(name: displayedProduct.name)
                
                displayPrice(price: displayedProduct.price, oldPrice:  displayedProduct.oldPrice)
                
                displayDescription(description: displayedProduct.description)
                
                displayWeight(weight: displayedProduct.weight)
                
                displayReview(review: displayedProduct.review, totalReviewsCount: displayedProduct.totalReviewsCount)

                displayRating(rating: displayedProduct.avgRating, totalReviews: displayedProduct.totalReviewsCount)
                
                displayIngredients(ingredients: displayedProduct.ingredients)
                
                displayPromotion(promotion: displayedProduct.promotion)
                
                displayFeatures(product: displayedProduct)
                displayDimensions(product: displayedProduct)
                
                displayAllergen(product: displayedProduct)
                displaydietary(product: displayedProduct)
                
                displayCategory(category: displayedProduct.category)
                
                displayRecommended(recommended: displayedProduct.recommended)
            }
        }
    }
    
    func displayListItem(viewModel: ShowProduct.GetListItem.ViewModel) {
        if let listItem = viewModel.listItem {
            displayStepper()
            displayQuantity(quantity: listItem.quantity)
        }
    }
    
    func displayCreatedListItem(viewModel: ShowProduct.CreateListItem.ViewModel) {
        // Update quantity, hide add button if success
        if let error = viewModel.error, !viewModel.offline {
            showError(title: "List Error", error: error)
        } else {
            if let listItem = viewModel.listItem {
                displayStepper()
                displayQuantity(quantity: listItem.quantity)
            } else if viewModel.offline {
                displayStepper()
                displayQuantity(quantity: 1)
            }
        }
        
    }
    
    func displayUpdatedListItem(viewModel: ShowProduct.UpdateListItem.ViewModel) {
        if let error = viewModel.error, !viewModel.offline {
            showError(title: "List Error", error: error)
        }
    }
}

extension ShowProductViewController {
    
    func displayPromotion(promotion: ShowProduct.DisplayedPromotion?){
        promotionView.isHidden = promotion == nil
        
        if let promotion = promotion {
            promotionLabel.text = promotion.name
        }
    }
    
    func displayName(name: String){
        nameLabel.text = name
    }

    func displayImages(largeImage: String?, images productImages: [String]){
        var images: [String] = []
        
        if let image = largeImage {
            images.append(image)
        }
        
        for image in productImages {
            images.append(image)
        }
        
        createSlideShowImages(images: images)
    }
    
    func displayPrice(price: String, oldPrice: String?){
        priceLabel.text = price
        oldPriceView.isHidden = oldPrice == nil
        
        if let oldPrice = oldPrice {
            oldPriceLabel.text = oldPrice
        }
    }
    
    func displayDescription(description: String){
        if description == "" {
            descriptionStackView.isHidden = true
        } else {
            descriptionStackView.isHidden = false
            descriptionLabel.text = description
            
            descriptionExpandView.isHidden = description.count < 150
        }
       
    }
    
    func displayWeight(weight: String?){
        weightParentView.isHidden = weight == nil
        
        if let weight = weight {
            weightLabel.text = weight
        }
    }
    
    func displayReview(review: ReviewModel?, totalReviewsCount: Int){
        allReviewsButton.setTitle("All Reviews (\(totalReviewsCount))", for: .normal)
        
        if let review = review {
            reviews.append(review)
            reviewsStackView.isHidden = false
            allReviewsView.isHidden = false
            reviewsTableView.reloadData()
        } else {
            reviewsStackView.isHidden = true
            allReviewsView.isHidden = true
        }
    }
    
    func displayRating(rating: Double, totalReviews: Int){
        ratingView.rating = rating
        ratingView.text = "(\(totalReviews))"
    }
    
    func displayIngredients(ingredients: [String]){
        ingredientsView.isHidden = ingredients.count == 0
    }
    
    func displayCategory(category: ShowProduct.DisplayedCategory?){
        categoriesView.isHidden = category == nil
        
        if let category = category {
            categoriesNameLabel.text = category.name
        }
    }
    
    func displayRecommended(recommended: [ProductModel]){
        recommendedProducts = recommended
        recommendedTableView.reloadData()
        recommendedView.isHidden = recommendedProducts.count == 0
    }
    
    func displayFeatures(product: ShowProduct.DisplayedProduct){
        featuresView.isHidden = product.features == nil
    }
    
    func displayDimensions(product: ShowProduct.DisplayedProduct){
        dimensionsView.isHidden = product.dimensions == nil
    }
    
    func displayAllergen(product: ShowProduct.DisplayedProduct) {
        if product.allergenInfo == nil || product.allergenInfo == "" {
            allergenView.isHidden = true
        } else {
            allergenLabel.text = product.allergenInfo
            allergenView.isHidden = false
        }
    }
    
    func displaydietary(product: ShowProduct.DisplayedProduct) {
        
        if product.dietaryInfo == nil || product.dietaryInfo == "" {
            dietaryView.isHidden = true
        } else {
            lifeStyleLabel.text = product.dietaryInfo
            dietaryView.isHidden = false
        }
    }
    
    
    func displayMonitoring(viewModel: ShowProduct.UpdateMonitoring.ViewModel) {
        if let error = viewModel.error {
            showError(title: "Monitor Error", error: error)
        }
    }
    
    func displayFavourite(viewModel: ShowProduct.UpdateFavourite.ViewModel) {
        if let error = viewModel.error {
            showError(title: "Favourite Error", error: error)
        }
    }
}

extension ShowProductViewController {
    func displayQuantity(quantity: Int){
        quantityStepper.value = Double(quantity)
        quantityLabel.text = String(quantity)
    }
    
    func displayStepper(){
        addButton.isHidden = true
        stepperStackView.isHidden = false
    }
    
    func displayAddButton(){
        addButton.isHidden = false
        stepperStackView.isHidden = true
    }
}

extension ShowProductViewController {
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
       if (traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection)) {
            weightView.layer.borderColor = UIColor(named: "LightGrey")!.cgColor
            addButton.layer.borderColor = UIColor(named: "LogoBlue.Light")!.cgColor
       }
    }
    
    func addBorders(){
        let views: [UIView] = [weightView, addButton]
        
        for (index, view) in views.enumerated() {
            view.layer.borderWidth = 2
            view.layer.borderColor = UIColor(named: index == 0 ? "LightGrey" : "LogoBlue.Light")!.cgColor
            view.layer.cornerRadius = 4
        }
    }
}
extension ShowProductViewController {
    func toggleMonitorButton(monitor: Bool) {
        let barItem:UIBarButtonItem
        
        if monitor == true {
            barItem = UIBarButtonItem(title: nil, style: .plain, target: self, action: #selector(monitorButtonPressed))
            barItem.image = UIImage(systemName: "bell.fill")
        } else {
            barItem = UIBarButtonItem(title: nil, style: .plain, target: self, action: #selector(monitorButtonPressed))
            barItem.image = UIImage(systemName: "bell")
        }
        
        barItem.tintColor = .systemYellow
        self.navigationItem.rightBarButtonItem = barItem
    }
    
    func toggleFavouriteButton(favourite: Bool) {
        let imageName: String = favourite ? "suit.heart.fill" : "suit.heart"
        favouriteButton.setImage(UIImage(systemName: imageName)!, for: .normal)
    }
}

extension ShowProductViewController {
    @IBAction func monitorButtonPressed(_ sender: Any) {
        
        if !loggedIn {
            router?.routeToLogin(segue: nil)
        } else {
            if let displayedProduct = displayedProduct {
                let monitoring: Bool = !displayedProduct.monitoring
                self.displayedProduct!.monitoring = monitoring
                
                toggleMonitorButton(monitor: monitoring)
                
                let request = ShowProduct.UpdateMonitoring.Request(monitor: monitoring)
                interactor?.updateMonitoring(request: request)
            }
        }
        
    }
    
    @IBAction func favouriteButtonPressed(_ sender: Any) {
        
        if !loggedIn {
            router?.routeToLogin(segue: nil)
        } else {
            if let displayedProduct = displayedProduct {
                let favourite: Bool = !displayedProduct.favourite
                
                toggleFavouriteButton(favourite: favourite)
                
                let request = ShowProduct.UpdateFavourite.Request(favourite: favourite)
                interactor?.updateFavourite(request: request)
                
                self.displayedProduct!.favourite = favourite
            }
        }
    }
    
    @IBAction func reviewButtonPressed(_ sender: Any) {
        loggedIn ? router?.routeToEditReview(segue: nil) : router?.routeToLogin(segue: nil)
    }
    
    @IBAction func allReviewButtonPressed(_ sender: Any) {
        router?.routeToShowReviews(segue: nil)
    }
    
}

extension ShowProductViewController {
    func setupDescriptionGesture(){
        let descriptionGesture = UITapGestureRecognizer(target: self, action: #selector(expandMinimiseDescription))
        descriptionStackView.addGestureRecognizer(descriptionGesture)
    }
    
    @objc func expandMinimiseDescription(){
        descriptionLabel.numberOfLines = fullDescription ? 3 : 0
        fullDescription = !fullDescription
        showDescriptionButton()
    }
    
    func showDescriptionButton(){
        // Expand Or Minimise
        let imageName: String = fullDescription ? "chevron.up" : "chevron.down"
        descriptionButton.setImage(UIImage(systemName: imageName)!, for: .normal)
    }
}

//MARK: - Setup View Gestures
extension ShowProductViewController {
    
    func setupGestureRecognizer(){
        let ingredientsPressedGesture = UITapGestureRecognizer(target: self, action: #selector(ingredientsButtonPressed))
        ingredientsView.addGestureRecognizer(ingredientsPressedGesture)
        
        let descriptionPressedGesture = UITapGestureRecognizer(target: self, action: #selector(nutritionButtonPressed))
        nutritionView.addGestureRecognizer(descriptionPressedGesture)
        
        let promotionPressedGesture = UITapGestureRecognizer(target: self, action: #selector(promotionButtonPressed))
        promotionView.addGestureRecognizer(promotionPressedGesture)
        
        let featuresPressedGesture = UITapGestureRecognizer(target: self, action: #selector(featuresButtonPressed))
        featuresView.addGestureRecognizer(featuresPressedGesture)
        
        let dimensionsPressedGesture = UITapGestureRecognizer(target: self, action: #selector(dimensionsButtonPressed))
        dimensionsView.addGestureRecognizer(dimensionsPressedGesture)
        
        let categoriesPressedGesture = UITapGestureRecognizer(target: self, action: #selector(categoriesButtonPressed))
        categoriesView.addGestureRecognizer(categoriesPressedGesture)
        
        setupDescriptionGesture()
    }
    
    @objc func promotionButtonPressed(){
        router?.routeToShowPromotion(segue: nil)
    }
    
    @objc func ingredientsButtonPressed(){
        router?.routeToShowIngredients(segue: nil)
    }
    
    @objc func categoriesButtonPressed(){
        router?.routeToChildCategories(segue: nil)
    }
    
    @objc func nutritionButtonPressed(){
        router?.routeToShowNutrition(segue: nil)
    }
    
    @objc func featuresButtonPressed(){
        router?.routeToShowFeatures(segue: nil)
    }
    
    @objc func dimensionsButtonPressed(){
        router?.routeToShowDimensions(segue: nil)
    }
    
}

//MARK: - Setup TableView
extension ShowProductViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return loading ? 1 : (tableView == reviewsTableView ? reviews.count : 1)
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        return tableView == reviewsTableView ? configureReviewCell(indexPath: indexPath) : configureProductsCell(indexPath: indexPath)
    }
    
    func configureReviewCell(indexPath: IndexPath) -> ReviewCell {
        let cell = reviewsTableView.dequeueReusableCell(withIdentifier: "ReviewCell", for: indexPath) as! ReviewCell
        
        if reviews.count > 0 {
            cell.review = reviews[indexPath.row]
        }
        
        cell.loading = loading
        cell.configureUI()
        
        cell.selectionStyle = UITableViewCell.SelectionStyle.none
        
        return cell
    }
    
    func configureProductsCell(indexPath: IndexPath) -> ProductsCell {
        let cell = recommendedTableView.dequeueReusableCell(withIdentifier: "ProductsCell", for: indexPath) as! ProductsCell
        
        cell.selectionStyle = UITableViewCell.SelectionStyle.none
        
        let productElement = ProductsElementModel(products: recommendedProducts)
        productElement.productPressed = productPressed
        productElement.scrolled = scrolled
        productElement.scrollPosition = scrollPosition
        productElement.loading = loading
        
        cell.configure(model: productElement)
        
        return cell
    }
    
    func registerReviewsTableView(){
        let reviewCellNib = UINib(nibName: "ReviewCell", bundle: nil)
        reviewsTableView.register(reviewCellNib, forCellReuseIdentifier: "ReviewCell")
        
        let productsCellNib = UINib(nibName: "ProductsCell", bundle: nil)
        recommendedTableView.register(productsCellNib, forCellReuseIdentifier: "ProductsCell")
        
        reviewsTableView.delegate = self
        reviewsTableView.dataSource = self
        
        recommendedTableView.delegate = self
        recommendedTableView.dataSource = self
    }
}

//MARK: - CallBacks
extension ShowProductViewController {
    func scrolled(_: Int, position: CGFloat){
        scrollPosition = position
    }
    
    private func productPressed(productID: Int){
        router?.selectedProductID = productID
        router?.routeToShowProduct(segue: nil)
    }
}

extension ShowProductViewController: UserLoggedInProtocol {
    func userLoggedInSuccessfully(){
        getProduct()
    }
}

//MARK: - List Handling
extension ShowProductViewController: SelectListProtocol {
    
    @IBAction func addToListButtonPressed(_ sender: Any) {
        
        if product.parentCategoryName == nil || product.parentCategoryName == nil {
            showError(title: "Internet connection required", error: "Please connect to internet to add this product to your list.")
        }
        
        if !loggedIn {
            router?.routeToLogin(segue: nil)
            return
        }
        
        if interactor?.selectedListID != nil {
            displayStepper()
            
            let listID: Int = interactor!.selectedListID!
            createListItem(listID: listID)
        } else {
            router?.routeToShowLists(segue: nil)
        }
    }
    
    @IBAction func quantityStepperPressed(_ sender: UIStepper) {
        
        let quantity = Int(sender.value)
        
        let listID: Int = interactor!.selectedListID!
        
        if quantity == 0 {
            interactor?.selectedListID = nil
            displayAddButton()
        } else {
            displayQuantity(quantity: quantity)
        }
        
        updateListItem(listID: listID, quantity: quantity)
    }
    
    func updateListItem(listID: Int, quantity: Int){
        let request = ShowProduct.UpdateListItem.Request(listID: listID, productID: product.id, quantity: quantity)
        interactor?.updateListItem(request: request)
    }
    
    func createListItem(listID: Int){
        let request = ShowProduct.CreateListItem.Request(listID: listID)
        interactor?.createListItem(request: request)
    }
    
    func listSelected(listID: Int) {
        displayQuantity(quantity: 1)
        
        interactor?.selectedListID = listID
        interactor?.listSelectedFromProduct = true
        
        createListItem(listID: listID)
    }
}


extension ShowProductViewController: ImageSlideshowDelegate {
    func setupImageSlider(){
        
        slideshow.contentScaleMode = .scaleAspectFit
        
        slideshow.activityIndicator = DefaultActivityIndicator(style: .medium, color: .label)
        
        slideshow.zoomEnabled = true
        slideshow.pageIndicatorPosition = .init(horizontal: .center, vertical: .under)
        
        let pageIndicator = UIPageControl()
        pageIndicator.currentPageIndicatorTintColor = .label
        pageIndicator.pageIndicatorTintColor = .quaternaryLabel

        slideshow.pageIndicator = pageIndicator
        
        slideshow.activityIndicator = DefaultActivityIndicator()
        slideshow.delegate = self
        
        setupImageGesture()
    }
    
    func createSlideShowImages(images: [String]){
        var sources: [InputSource] = []
        
        if images.count > 0 {
            for image in images {
                if let imageSource = AlamofireSource(urlString: image) {
                    sources.append(imageSource)
                } else {
                    sources.append(ImageSource(image: UIImage(named: "No Image")!))
                }
            }
        } else {
            sources.append(ImageSource(image: UIImage(named: "No Image")!))
        }
        
        slideshow.setImageInputs(sources)
    }
    
    func setupImageGesture(){
        let gestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(imagePressed))
        slideshow.addGestureRecognizer(gestureRecognizer)
    }
    
    @objc func imagePressed() {
        slideshow.presentFullScreenController(from: self)
    }
    
}
