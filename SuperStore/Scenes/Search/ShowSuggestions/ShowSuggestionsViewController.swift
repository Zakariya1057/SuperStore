//
//  ShowSuggestionsViewController.swift
//  SuperStore
//
//  Created by Zakariya Mohummed on 02/03/2021.
//  Copyright (c) 2021 Zakariya Mohummed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import FuzzyMatchingSwift

protocol ShowSuggestionsDisplayLogic: AnyObject
{
    func displaySuggestions(viewModel: ShowSuggestions.GetSuggestions.ViewModel)
    func displayRecentSuggestions(viewModel: ShowSuggestions.GetRecentSuggestions.ViewModel)
}

class ShowSuggestionsViewController: UIViewController, ShowSuggestionsDisplayLogic
{
    var interactor: ShowSuggestionsBusinessLogic?
    var router: (NSObjectProtocol & ShowSuggestionsRoutingLogic & ShowSuggestionsDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = ShowSuggestionsInteractor()
        let presenter = ShowSuggestionsPresenter()
        let router = ShowSuggestionsRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        displayRightBarButton()
        getRecentSuggestions()
        setupFavouriteTableView()
        setupSearchDelegate()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if userSession.getStore() != currentStoreTypeID  {
            currentStoreTypeID = userSession.getStore()
            search()
        }
    }
    
    var loading: Bool = true
    
    let similarWorker = SimilarWorker()
    
    var recentSuggestionsLimit: Int = 7
    
    @IBOutlet var suggestionsTableView: UITableView!
    @IBOutlet var searchBar: UISearchBar!
    
    var suggestions: [SuggestionModel] = []
    
    var currentStoreTypeID: Int = 0
    var userSession: UserSessionWorker = UserSessionWorker()
    
    var displayRecentSuggestions: Bool = false
    
    func getRecentSuggestions(){
        let request = ShowSuggestions.GetRecentSuggestions.Request(limit: recentSuggestionsLimit)
        interactor?.getRecentSuggestions(request: request)
    }
    
    func search(){
        let searchText = searchBar.text ?? ""
        
        loading = true
        suggestionsTableView.reloadData()
        
        if searchText.replacingOccurrences(of: " ", with: "") == "" {
            displayRecentSuggestions = true
            getRecentSuggestions()
        } else {
            displayRecentSuggestions = false
            let request = ShowSuggestions.GetSuggestions.Request(query: searchText)
            interactor?.getSuggestions(request: request)
        }
    }
    
    func displaySuggestions(viewModel: ShowSuggestions.GetSuggestions.ViewModel)
    {
        if let error = viewModel.error {
            if !viewModel.offline {
                showError(title: "Search Error", error: error)
            }
        } else {
            loading = false
            
            if viewModel.suggestions.count == 0 && displayRecentSuggestions {
                print("Late loaded empty suggestions list not showing. Display recent suggestions instead")
            } else {
                self.suggestions = viewModel.suggestions
            }
           
            suggestionsTableView.reloadData()
        }
    }
    
    func displayRecentSuggestions(viewModel: ShowSuggestions.GetRecentSuggestions.ViewModel){
        
        loading = false
        
        if let error = viewModel.error {
            showError(title: "Suggestion Error", error: error)
        } else {
            self.suggestions = viewModel.suggestions
            suggestionsTableView.reloadData()
        }
    }
    
    func displayRightBarButton(){
        if interactor?.selectedListID == nil {
            self.navigationItem.rightBarButtonItem = nil
        }
    }
}

extension ShowSuggestionsViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return loading ? 3 : suggestions.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        return configureSuggestionCell(indexPath: indexPath)
    }
    
    func configureSuggestionCell(indexPath: IndexPath) -> SearchSuggestionCell {
        let cell = suggestionsTableView.dequeueReusableCell(withIdentifier: "SearchSuggestionCell", for: indexPath) as! SearchSuggestionCell
        
        cell.loading = loading
        cell.suggestion = loading ? nil : suggestions[indexPath.row]
        cell.configureUI()
        
        cell.selectionStyle = UITableViewCell.SelectionStyle.none
        
        return cell
    }
    
    func setupFavouriteTableView(){
        let suggestionCellNib = UINib(nibName: "SearchSuggestionCell", bundle: nil)
        suggestionsTableView.register(suggestionCellNib, forCellReuseIdentifier: "SearchSuggestionCell")
        
        suggestionsTableView.delegate = self
        suggestionsTableView.dataSource = self
    }
}

extension ShowSuggestionsViewController {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let suggestion: SuggestionModel = suggestions[indexPath.row]
        suggestionSelected(suggestion: suggestion)
    }
    
    private func suggestionSelected(suggestion: SuggestionModel){
        interactor?.suggestionSelected(suggestion: suggestion)
        
        if suggestion.type == .store {
            router?.selectedStoreTypeID = suggestion.id
            router?.routeToShowStoreResults(segue: nil)
        } else {
            router?.routeToShowProductResults(segue: nil)
        }
    }
}

extension ShowSuggestionsViewController: UISearchBarDelegate {
    
    private func setupSearchDelegate(){
        searchBar.delegate = self
    }
    
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        search()
    }

    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        textSearch(searchText: searchBar.text ?? "")
    }
}

extension ShowSuggestionsViewController {
    private func textSearch(searchText: String){
        
        if searchText.replacingOccurrences(of: " ", with: "") == "" {
            return
        }
        
        // Check if the search term exists in suggestion. If it does, then user was trying to search for that instead.

        // 1. If in suggestion then use contains to find the correct suggestion
        // 2. If in suggestion but has a speeling mistake
        // 3. Not in suggestions. Just use text search as normal.
        
        // If no brand, store, category, or promotion then go straight for text search.
        let wantedSuggestionTypesFound: Bool = suggestions.first{  return isOverrideSuggestionType(type: $0.type)  } != nil
        
        if !loading && wantedSuggestionTypesFound {
            
            let (exactSuggestionMatch, mostSimilarSuggestion, mostConfidenceSuggestion) = getMatchingSuggestions(searchText: searchText)
            
            textSearchSelectSuggestion(
                searchText: searchText,
                exactSuggestionMatch: exactSuggestionMatch,
                mostSimilarSuggestion: mostSimilarSuggestion,
                mostConfidenceSuggestion: mostConfidenceSuggestion
            )
            
        } else {
            
            print("No Wanted Suggestions Options Found")
            
            if searchText.replacingOccurrences(of: " ", with: "") != "" {
                interactor?.textSearch(query: searchText)
                router?.routeToShowProductResults(segue: nil)
            }
            
        }
    }
    
    private func getMatchingSuggestions(searchText: String) -> (SuggestionModel?, SuggestionModel?, SuggestionModel?){
        
        var mostDifference: Int? = nil
        var mostConfidence: Double? = nil
        var exactMatchDifference: Int? = nil
        
        var exactSuggestionMatch: SuggestionModel? = nil
        var mostSimilarSuggestion: SuggestionModel? = nil
        var mostConfidenceSuggestion: SuggestionModel? = nil
        
        let exactMatch = suggestions.first { (suggestion) -> Bool in
            return
                suggestion.name.lowercased() == searchText.lowercased() ||
                suggestion.name.lowercased() == searchText.lowercased() + "s" ||
                suggestion.name.lowercased() + "s" == searchText.lowercased() + "s" 
        }
        
        if exactMatch == nil {
            for suggestion in suggestions {
                if isOverrideSuggestionType(type: suggestion.type) {
                    
                    let textDifference = similarWorker.textDifference(searchText, suggestion.name)
                    print("\(suggestion.name): \(textDifference)")
                    
                    if textDifference < 7 && suggestion.name.lowercased().contains(searchText.lowercased())  {
                        
                        if let difference = exactMatchDifference {
                            if textDifference == exactMatchDifference && suggestion.name.lowercased() == searchText.lowercased() {
                                exactSuggestionMatch = suggestion
                                exactMatchDifference = 0
                            } else {
                                if textDifference < difference {
                                    exactSuggestionMatch = suggestion
                                    exactMatchDifference = textDifference
                                }
                            }
                        } else {
                            exactSuggestionMatch = suggestion
                            exactMatchDifference = textDifference
                        }
                        
                    } else {
                        let confidence = searchText.confidenceScore(suggestion.name)
                       
                        if let confidence = confidence {
                            if mostConfidence == nil || confidence < mostConfidence! {
                                mostConfidence = confidence
                                mostConfidenceSuggestion = suggestion
                            }
                        }

                        if mostDifference == nil || textDifference < mostDifference! {
                            mostDifference = textDifference
                            mostSimilarSuggestion = suggestion
                        }
                    }
                    
                }
                    
            }
            
        } else {
            exactSuggestionMatch = exactMatch
            exactMatchDifference = 0
        }

        return (exactSuggestionMatch, mostSimilarSuggestion, mostConfidenceSuggestion)
    }
    
    private func textSearchSelectSuggestion(searchText: String, exactSuggestionMatch: SuggestionModel?, mostSimilarSuggestion: SuggestionModel?, mostConfidenceSuggestion: SuggestionModel?){
        
        if let exactSuggestionMatch = exactSuggestionMatch {
            print(exactSuggestionMatch)
            suggestionSelected(suggestion: exactSuggestionMatch)
            print("Exact Suggestion Match Found")
        } else if let confidentSuggestion = mostConfidenceSuggestion, let similarSuggestion = mostSimilarSuggestion {
            
            if confidentSuggestion.id == similarSuggestion.id && confidentSuggestion.type == similarSuggestion.type {
                print("Only one suggestion found")
                print(confidentSuggestion)
                
                if similarWorker.textDifference(confidentSuggestion.name.lowercased(), searchText.lowercased()) < 7 {
                    suggestionSelected(suggestion: similarSuggestion)
                    
                    suggestions.append(SuggestionModel(id: 1, name: searchText, type: .product, textSearch: true, storeTypeID: currentStoreTypeID))
                    suggestionsTableView.reloadData()
                } else {
                    interactor?.textSearch(query: searchText)
                    router?.routeToShowProductResults(segue: nil)
                }
            } else if similarWorker.textDifference(confidentSuggestion.name.lowercased(), searchText.lowercased()) < 7 {
                suggestionSelected(suggestion: confidentSuggestion)
            } else if similarWorker.textDifference(similarSuggestion.name.lowercased(), searchText.lowercased()) < 7 {
                suggestionSelected(suggestion: similarSuggestion)
            } else {
                interactor?.textSearch(query: searchText)
                router?.routeToShowProductResults(segue: nil)
            }
        } else {
            interactor?.textSearch(query: searchText)
            router?.routeToShowProductResults(segue: nil)
        }
    }
    
    private func isOverrideSuggestionType(type: SearchType) -> Bool {
        return
            type == .store ||
            type == .parentCategory ||
            type == .childCategory ||
            type == .promotion ||
            type == .brand ||
            type == .storeSale
    }

}

extension ShowSuggestionsViewController {
    @IBAction func doneButtonPressed(_ sender: UIBarButtonItem) {
        router?.routeToShowList(segue: nil)
    }
}
