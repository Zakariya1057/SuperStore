//
//  ShowProductResultsInteractor.swift
//  SuperStore
//
//  Created by Zakariya Mohummed on 02/03/2021.
//  Copyright (c) 2021 Zakariya Mohummed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Foundation

protocol ShowProductResultsBusinessLogic
{
    func getResults(request: ShowProductResults.GetResults.Request)
    
    var searchQueryRequest: SearchQueryRequest { get set }
    var selectedRefineOptions: SelectedRefineOptions { get set }
    var searchRefine: SearchRefine { get set }
    
    var selectedListID: Int? { get set }
    var selectedProductCompanyID: Int? { get set }
    
    var title: String { get set }
    var childCategoryID: Int? { get set }
    
    func getListItems(request: ShowProductResults.GetListItems.Request)
    func createListItem(request: ShowProductResults.CreateListItem.Request)
    func updateListItem(request: ShowProductResults.UpdateListItem.Request)
    
    func getCategoryProducts(request: ShowProductResults.GetCategoryProducts.Request)
    func sortOptionSelected(option: RefineSortOptionModel)
}

protocol ShowProductResultsDataStore
{
    var searchQueryRequest: SearchQueryRequest { get set }
    var selectedRefineOptions: SelectedRefineOptions { get set }
    var searchRefine: SearchRefine { get set }
    
    var selectedListID: Int? { get set }
    var selectedProductCompanyID: Int? { get set }
    
    var title: String { get set }
    var childCategoryID: Int? { get set }
}

class ShowProductResultsInteractor: ShowProductResultsBusinessLogic, ShowProductResultsDataStore
{
    
    var presenter: ShowProductResultsPresentationLogic?
    
    var groceryWorker: GroceryWorker = GroceryWorker(groceryAPI: GroceryAPI())
    var searchWorker: SearchWorker = SearchWorker(searchAPI: SearchAPI())
    var listItemWorker: ListItemWorker = ListItemWorker(listItemAPI: ListItemAPI())
    
    var userSession = UserSessionWorker()
    
    var searchRefine: SearchRefine = SearchRefine(availabilityType: [], brands: [], productGroups: [], promotions: [])
    var searchQueryRequest: SearchQueryRequest = SearchQueryRequest(query: "", type: "", sort: "", supermarketChainID: 0, regionID: 0)
    
    var products: [ProductModel] = []
    
    var title: String = ""
    var childCategoryID: Int? = nil
    
    var selectedListID: Int?
    var selectedProductCompanyID: Int?
    
    var refineOptionsSet: Bool = false
    
    var regionID: Int {
        return userSession.getRegion()
    }
    
    var supermarketChainID: Int {
        return userSession.getSupermarketChainID()
    }
    
    var selectedSortOption: RefineSortOptionModel = RefineSortOptionModel(name: "Relevance", type: .relevance)
    
    var selectedRefineOptions: SelectedRefineOptions = SelectedRefineOptions() {
        didSet {
            refineResults()
        }
    }
    
    func getResults(request: ShowProductResults.GetResults.Request)
    {
        
        let page: Int = request.page
        let refine: Bool = request.refineSort
        
        searchQueryRequest.refineSort = refine
        
        searchWorker.getProductResults(query: searchQueryRequest, page: page) { (results: ProductResultsModel?, error: String?) in
            
            if let results = results {
                if page > 1 {
                    // Append To Current Products.
                    self.products.append(contentsOf: results.products)
                } else {
                    // New Products Set. Override.
                    self.products = results.products
                }
                
                self.setRefineOptions(products:  self.products)
            }
            
            var response = ShowProductResults.GetResults.Response(products: results?.products ?? [], paginate: results?.paginate, error: error)
            
            if error != nil {
                response.offline = !self.userSession.isOnline()
            }
            
            self.presenter?.presentResults(response: response)
        }
    
    }

    func refineResults(){
        
        resetRefineResults()
        
        if let selectedProductGroup = selectedRefineOptions.productGroup.first {
            searchQueryRequest.productGroup = selectedProductGroup.name
        }
        
        if let selectedBrand = selectedRefineOptions.brand.first {
            searchQueryRequest.brand = selectedBrand.name
        }
        
        if let selectedPromotion = selectedRefineOptions.promotion.first {
            searchQueryRequest.promotion = removeTitleFromPromotion(text: selectedPromotion.name)
        }
        
        if let selectedAvailabilityType = selectedRefineOptions.availabilityType.first {
            searchQueryRequest.availabilityType = selectedAvailabilityType.name
        }

        searchQueryRequest.refineSort = true
        searchQueryRequest.dietary = selectedRefineOptions.dietary.compactMap({ $0.name }).joined(separator: ",")
        
        if refineOptionsNotSet() {
            selectedSortOption = RefineSortOptionModel(name: "Relevance", type: .relevance)
        }
        
        searchQueryRequest.order = selectedSortOption.order?.rawValue ?? ""
        searchQueryRequest.sort = selectedSortOption.type.rawValue
    }

}

extension ShowProductResultsInteractor {
    func resetRefineResults(){
        searchQueryRequest.sort = ""
        searchQueryRequest.order = ""
        searchQueryRequest.dietary = ""
        searchQueryRequest.brand = ""
        searchQueryRequest.promotion = ""
        searchQueryRequest.productGroup = ""
        searchQueryRequest.availabilityType = ""
    }
    
    func refineOptionsNotSet() -> Bool {
        return
            searchQueryRequest.dietary == "" &&
            searchQueryRequest.brand == "" &&
            searchQueryRequest.productGroup == "" &&
            searchQueryRequest.promotion == "" &&
            searchQueryRequest.availabilityType == ""
    }
}

extension ShowProductResultsInteractor {
    func getListItems(request: ShowProductResults.GetListItems.Request){
        if let selectedListID = selectedListID {
            listItemWorker.getItems(listID: selectedListID) { (listItems: [ListItemModel]) in
                let response = ShowProductResults.GetListItems.Response(listItems: listItems)
                self.presenter?.presentListItems(response: response)
            }
        }
    }
    
    func createListItem(request: ShowProductResults.CreateListItem.Request){
        let listID: Int = request.listID
        let product: ProductModel = request.product
        
        listItemWorker.createItem(listID: listID, product: product) { (listItem: ListItemModel?, error: String?) in
            var response = ShowProductResults.CreateListItem.Response(listItem: listItem, error: error)
            
            if error != nil {
                response.offline = !self.userSession.isOnline()
            }
            
            self.presenter?.presentListItemCreated(response: response)
        }
    }
    
    func updateListItem(request: ShowProductResults.UpdateListItem.Request){
        let listID: Int = request.listID
        let productID: Int = request.productID
        let quantity: Int = request.quantity
        
        listItemWorker.updateItem(listID: listID, productID: productID, quantity: quantity, tickedOff: false) { (error: String?) in
            var response = ShowProductResults.UpdateListItem.Response(error: error)
            
            if error != nil {
                response.offline = !self.userSession.isOnline()
            }
            
            self.presenter?.presentListItemUpdated(response: response)
        }
    }
}


extension ShowProductResultsInteractor {
    func getCategoryProducts(request: ShowProductResults.GetCategoryProducts.Request){
        let page: Int = request.page
        let refineSort: Bool = request.refineSort
        
        searchQueryRequest.refineSort = refineSort
        
        searchQueryRequest.regionID = regionID
        searchQueryRequest.supermarketChainID = supermarketChainID
        
        groceryWorker.getCategoryProducts(
            childCategoryID: childCategoryID!,
            data: searchQueryRequest,
            page: page
        ) { (category: ChildCategoryModel?, error: String?) in
            
            var response = ShowProductResults.GetCategoryProducts.Response(category: category, error: error)
            
            if let category = category {
                self.setRefineOptions(products: category.products)
            }
            
            if error != nil {
                response.offline = !self.userSession.isOnline()
            }
            
            self.presenter?.presentCategoryProducts(response: response)
        }
        
    }
}

extension ShowProductResultsInteractor {
    func sortOptionSelected(option: RefineSortOptionModel){
        self.selectedSortOption = option
        searchQueryRequest.order = selectedSortOption.order?.rawValue ?? ""
        searchQueryRequest.sort = selectedSortOption.type.rawValue
    }
}

extension ShowProductResultsInteractor {
    private func setRefineOptions(products: [ProductModel]){
        // Unique Brands. Unique Categories
        var uniqueBrands: [String: Int] = [:]
        
        var uniqueProductGroups: [String: Int] = [:]
        var uniquePromotions: [String: Int] = [:]

        for product in products {
            if let brand = product.brand, brand != "" {
                if uniqueBrands[brand] != nil {
                    uniqueBrands[brand]! += 1
                } else {
                    uniqueBrands[brand] = 1
                }
            }
            
            if let productGroup = product.productGroupName, productGroup != "" {
                if uniqueProductGroups[productGroup] != nil {
                    uniqueProductGroups[productGroup]! += 1
                } else {
                    uniqueProductGroups[productGroup] = 1
                }
            }
            
            if let price = product.price, let promotion = price.promotion, promotion.name != "" {
                let title: String? = promotion.title ?? product.productGroupName ?? product.childCategoryName
                let promotionName: String = title == nil ? promotion.name : "\(title!) - \(promotion.name)"
                
                if uniquePromotions[promotion.name] != nil {
                    uniquePromotions[promotionName]! += 1
                } else {
                    uniquePromotions[promotionName] = 1
                }
            }
        }
        
        self.searchRefine.brands = uniqueBrands.sorted(by: { brand1, brand2 in brand1.value > brand2.value }).compactMap{ "\($0.key)" }
        self.searchRefine.productGroups = uniqueProductGroups.sorted(by: { productGroup1, productGroup2 in productGroup1.value > productGroup2.value }).compactMap{ "\($0.key)"}
        self.searchRefine.promotions = uniquePromotions.sorted(by: { promotion1, promotion2 in promotion1.value > promotion2.value }).compactMap{ "\($0.key)"}
    }
}

extension ShowProductResultsInteractor {
    private func removeTitleFromPromotion(text: String) -> String{
        return text.replacingOccurrences(
            of: "(.+\\s-\\s)",
            with: "",
            options: .regularExpression,
            range: text.startIndex ..< text.endIndex
        )
    }
}
